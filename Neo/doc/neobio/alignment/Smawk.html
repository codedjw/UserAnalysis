<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN""http://www.w3.org/TR/REC-html40/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc on Thu Sep 11 03:19:53 BRT 2003 -->
<TITLE>
Smawk (NeoBio API)
</TITLE>
<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">
</HEAD>
<SCRIPT>
function asd()
{
parent.document.title="Smawk (NeoBio API)";
}
</SCRIPT>
<BODY BGCOLOR="white" onload="asd();">

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_top"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<B><EM>NeoBio</EM> API</B></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../neobio/alignment/ScoringScheme.html"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../neobio/alignment/SmithWaterman.html"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Smawk.html" TARGET="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;
<SCRIPT>
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html" TARGET=""><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
<A HREF="../../allclasses-noframe.html" TARGET=""><B>All Classes</B></A>
</NOSCRIPT>
</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
neobio.alignment</FONT>
<BR>
Class  Smawk</H2>
<PRE>
java.lang.Object
  |
  +--<B>neobio.alignment.Smawk</B>
</PRE>
<HR>
<DL>
<DT>public class <A HREF="../../src-html\neobio\alignment\Smawk.html#line.101"><B>Smawk</B></A><DT>extends java.lang.Object</DL>

<P>
This class implement the SMAWK algorithm to compute column maxima on a totally monotone
 matrix as described.

 <P>This implementation derives from the paper of A.Aggarwal, M.Klawe, S.Moran, P.Shor,
 and R.Wilber, <I>Geometric Applications of a Matrix Searching Algorithm</I>,
 Algorithmica, 2, 195-208 (1987).</P>

 <P>The matrix must be an object that implements the <A HREF="../../neobio/alignment/Matrix.html">Matrix</A> interface. It
 is also expected to be totally monotone, and the number of rows should be greater than
 or equals to the number of columns. If these conditions are not met, the the result is
 unpredictable and can lead to an ArrayIndexOutOfBoundsException.</P>

 <P><A HREF="../../neobio/alignment/Smawk.html#computeColumnMaxima(neobio.alignment.Matrix, int[])"><CODE>computeColumnMaxima</CODE></A> is the main public method of this
 class. It computes the column maxima of a given matrix, i.e. the rows that contain the
 maximum value of each column in O(n) (linear) time, where n is the number of rows. This
 method does not return the maximum values itself, but just the indexes of their
 rows.</P>

 <P>Note that it is necessary to create an instance of this class to execute the
 <CODE>computeColumnMaxima</CODE> because it stores temporary data is that instance. To
 prevent problems with concurrent access, the <CODE>computeColumnMaxima</CODE> method is
 declared <CODE>synchronized</CODE>.

 <CODE><BLOCKQUOTE><PRE>
 // create an instance of Smawk
 Smawk smawk = new Smawk();

 // create an array to store the result
 int col_maxima = new int [some_matrix.numColumns()];

 // now compute column maxima
 smawk.computeColumnMaxima (some_matrix, col_maxima)
 </PRE></BLOCKQUOTE></CODE>

 <P>Note that the array of column maxima indexes (the computation result) must be
 created beforehand and its size must be equal to the number of columns of the
 matrix.</P>

 <P>This implementation creates arrays of row and column indexes from the original array
 and simulates all operations (reducing, deletion of odd columns, etc.) by manipulating
 these arrays. The benefit is two-fold. First the matrix is not required to implement
 any of these this operations but only a simple method to retrieve a value at a given
 position. Moreover, it tends to be faster since it uses a manipulation of these small
 vectors and no row or column is actually deleted. The downside is, of course, the use
 of extra memory (in practice, however, this is negligible).</P>

 <P>Note that this class does not contain a <CODE>computeRowMaxima</CODE> method,
 however, the <CODE>computeColumnMaxima</CODE> can easily be used to compute row maxima
 by using a transposed matrix interface, i.e. one that inverts the indexes of the
 <CODE>valueAt</CODE> method (returning [col,row] when [row,col] is requested) and swaps
 the number of rows by the number of columns, and vice-versa.</P>

 <P>Another simpler method, <A HREF="../../neobio/alignment/Smawk.html#naiveComputeColumnMaxima(neobio.alignment.Matrix, int[])"><CODE>naiveComputeColumnMaxima</CODE></A>,
 does the same job without using the SMAWK algorithm. It takes advantage of the monotone
 property of the matrix only (SMAWK explores the stronger constraint of total
 monotonicity), and therefore has a worst case time complexity of O(n * m), where n is
 the number of rows and m is the number of columns. However, this method tends to be
 faster for small matrices because it avoids recursions and row and column
 manipulations. There is also a
 <A HREF="../../neobio/alignment/Smawk.html#naiveComputeRowMaxima(neobio.alignment.Matrix, int[])">naiveComputeRowMaxima</A> method to compute row maxima
 with the naive approach.</P>
<P>

<P>
<DL>
<DT><B>Author:</B><DD>Sergio A. de Carvalho Jr.</DD>
</DD>
<DT><B>See Also:</B><DD><A HREF="../../neobio/alignment/Matrix.html"><CODE>Matrix</CODE></A></DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->


<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Field Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../neobio/alignment/Smawk.html#col">col</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;An array of column indexes reflecting the current state of the matrix. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../neobio/alignment/Matrix.html">Matrix</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../neobio/alignment/Smawk.html#matrix">matrix</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A pointer to the matrix that is being manipulated.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../neobio/alignment/Smawk.html#numcols">numcols</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The matrix's current number of columns. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../neobio/alignment/Smawk.html#numrows">numrows</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The matrix's current number of rows. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../neobio/alignment/Smawk.html#row">row</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;An array of row indexes reflecting the current state of the matrix. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../neobio/alignment/Smawk.html#row_position">row_position</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This array is used to store for each row of the original matrix, its index in the
 current state of the matrix, i.e. its index in the <CODE>row</CODE> array.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../neobio/alignment/Smawk.html#Smawk()">Smawk</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../neobio/alignment/Smawk.html#computeColumnMaxima(int[])">computeColumnMaxima</A></B>(int[]&nbsp;col_maxima)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method implements the SMAWK algorithm to compute the column maxima of a given
 matrix. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../neobio/alignment/Smawk.html#computeColumnMaxima(neobio.alignment.Matrix, int[])">computeColumnMaxima</A></B>(<A HREF="../../neobio/alignment/Matrix.html">Matrix</A>&nbsp;matrix,
                                       int[]&nbsp;col_maxima)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computes the column maxima of a given matrix. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../neobio/alignment/Smawk.html#deleteOddColumns()">deleteOddColumns</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method simulates a deletion of odd rows by manipulating the <CODE>col</CODE>
 array of indexes. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../neobio/alignment/Smawk.html#deleteRow(int, int)">deleteRow</A></B>(int&nbsp;reduced_rows,
                   int&nbsp;k)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method simulates a deletion of a row in the matrix during the
 <CODE>reduce</CODE> operation. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../neobio/alignment/Smawk.html#naiveComputeColumnMaxima(neobio.alignment.Matrix, int[])">naiveComputeColumnMaxima</A></B>(<A HREF="../../neobio/alignment/Matrix.html">Matrix</A>&nbsp;matrix,
                                                 int[]&nbsp;col_maxima)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This is a simpler method for calculating column maxima. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../neobio/alignment/Smawk.html#naiveComputeRowMaxima(neobio.alignment.Matrix, int[])">naiveComputeRowMaxima</A></B>(<A HREF="../../neobio/alignment/Matrix.html">Matrix</A>&nbsp;matrix,
                                           int[]&nbsp;row_maxima)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This is a simpler method for calculating row maxima. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../neobio/alignment/Smawk.html#printMatrix()">printMatrix</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Prints the current state of the matrix (reflecting deleted rows and columns) in the
 standard output. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../neobio/alignment/Smawk.html#printMatrix(neobio.alignment.Matrix)">printMatrix</A></B>(<A HREF="../../neobio/alignment/Matrix.html">Matrix</A>&nbsp;matrix)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Prints the contents of an object implementing the matrix interface in the standard
 output. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../neobio/alignment/Smawk.html#reduce()">reduce</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method is the key component of the SMAWK algorithm. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../neobio/alignment/Smawk.html#restoreOddColumns(int)">restoreOddColumns</A></B>(int&nbsp;original_numcols)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restores the <CODE>col</CODE> array of indexes to the state it was before the
 <CODE>deleteOddColumns</CODE> method was called. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../neobio/alignment/Smawk.html#restoreRows(int)">restoreRows</A></B>(int&nbsp;original_numrows)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restores the <CODE>row</CODE> array of indexes to the state it was before the
 <CODE>reduce</CODE> method was called. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../neobio/alignment/Smawk.html#valueAt(int, int)">valueAt</A></B>(int&nbsp;r,
               int&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This is a helper method to simplify the call to the <CODE>valueAt</CODE> method
 of the matrix. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class java.lang.Object</B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Field Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="matrix"><!-- --></A><H3>
matrix</H3>
<PRE>
protected <A HREF="../../neobio/alignment/Matrix.html">Matrix</A> <A HREF="../../src-html\neobio\alignment\Smawk.html#line.106"><B>matrix</B></A></PRE>
<DL>
<DD>A pointer to the matrix that is being manipulated.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="numrows"><!-- --></A><H3>
numrows</H3>
<PRE>
protected int <A HREF="../../src-html\neobio\alignment\Smawk.html#line.112"><B>numrows</B></A></PRE>
<DL>
<DD>The matrix's current number of rows. This reflects any deletion of rows already
 performed.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="row"><!-- --></A><H3>
row</H3>
<PRE>
protected int[] <A HREF="../../src-html\neobio\alignment\Smawk.html#line.118"><B>row</B></A></PRE>
<DL>
<DD>An array of row indexes reflecting the current state of the matrix. When rows are
 deleted, the corresponding indexes are simply moved to the end of the vector.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="row_position"><!-- --></A><H3>
row_position</H3>
<PRE>
protected int[] <A HREF="../../src-html\neobio\alignment\Smawk.html#line.124"><B>row_position</B></A></PRE>
<DL>
<DD>This array is used to store for each row of the original matrix, its index in the
 current state of the matrix, i.e. its index in the <CODE>row</CODE> array.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="numcols"><!-- --></A><H3>
numcols</H3>
<PRE>
protected int <A HREF="../../src-html\neobio\alignment\Smawk.html#line.130"><B>numcols</B></A></PRE>
<DL>
<DD>The matrix's current number of columns. This reflects any deletion of columns
 already performed.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="col"><!-- --></A><H3>
col</H3>
<PRE>
protected int[] <A HREF="../../src-html\neobio\alignment\Smawk.html#line.136"><B>col</B></A></PRE>
<DL>
<DD>An array of column indexes reflecting the current state of the matrix. When columns
 are deleted, the corresponding indexes are simply moved to the end of the vector.
<P>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="Smawk()"><!-- --></A><H3>
Smawk</H3>
<PRE>
public <B>Smawk</B>()</PRE>
<DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="computeColumnMaxima(neobio.alignment.Matrix, int[])"><!-- --></A><H3>
computeColumnMaxima</H3>
<PRE>
public void <A HREF="../../src-html\neobio\alignment\Smawk.html#line.162"><B>computeColumnMaxima</B></A>(<A HREF="../../neobio/alignment/Matrix.html">Matrix</A>&nbsp;matrix,
                                int[]&nbsp;col_maxima)</PRE>
<DL>
<DD>Computes the column maxima of a given matrix. It first sets up arrays of row and
 column indexes to simulate a copy of the matrix (where all operations will be
 performed). It then calls the recursive protected <CODE>computeColumnMaxima</CODE>
 method.

 <P>The matrix is required to be an object that implements the <CODE>Matrix</CODE>
 interface. It is also expected to be totally monotone, and the number of rows
 should be greater than or equals to the number of columns. If it is not, the the
 result is unpredictable and can lead to an ArrayIndexOutOfBoundsException.</P>

 <P>This method does not return the maximum values itself, but just the indexes of
 their rows. Note that the array of column maxima (the computation result) must be
 created beforehand and its size must be equal to the number of columns of the
 matrix.</P>

 <P>To prevent problems with concurrent access, this method is declared
 <CODE>synchronized</CODE>.</P>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>matrix</CODE> - the matrix that will have its column maxima computed<DD><CODE>col_maxima</CODE> - the array of column maxima (indexes of the rows containing
 maximum values of each column); this is the computation result<DT><B>See Also:</B><DD><A HREF="../../neobio/alignment/Smawk.html#computeColumnMaxima(int[])"><CODE>computeColumnMaxima(int[])</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="computeColumnMaxima(int[])"><!-- --></A><H3>
computeColumnMaxima</H3>
<PRE>
protected void <A HREF="../../src-html\neobio\alignment\Smawk.html#line.201"><B>computeColumnMaxima</B></A>(int[]&nbsp;col_maxima)</PRE>
<DL>
<DD>This method implements the SMAWK algorithm to compute the column maxima of a given
 matrix. It uses the arrays of row and column indexes to performs all operations on
 this 'fake' copy of the original matrix.

 <P>The first step is to reduce the matrix to a quadratic size (if necessary). It
 then delete all odd columns and recursively computes column maxima for this matrix.
 Finally, using the information computed for the odd columns, it searches for
 column maxima of the even columns. The column maxima are progressively stored in
 the <CODE>col_maxima</CODE> array (each recursive call will compute a set of
 column maxima).</P>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>col_maxima</CODE> - the array of column maxima (the computation result)</DL>
</DD>
</DL>
<HR>

<A NAME="valueAt(int, int)"><!-- --></A><H3>
valueAt</H3>
<PRE>
protected final int <A HREF="../../src-html\neobio\alignment\Smawk.html#line.284"><B>valueAt</B></A>(int&nbsp;r,
                            int&nbsp;c)</PRE>
<DL>
<DD>This is a helper method to simplify the call to the <CODE>valueAt</CODE> method
 of the matrix. It returns the value at row <CODE>r</CODE>, column <CODE>c</CODE>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>r</CODE> - the row number of the value being retrieved<DD><CODE>c</CODE> - the column number of the value being retrieved
<DT><B>Returns:</B><DD>the value at row <CODE>r</CODE>, column <CODE>c</CODE><DT><B>See Also:</B><DD><A HREF="../../neobio/alignment/Matrix.html#valueAt(int, int)"><CODE>Matrix.valueAt(int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="deleteOddColumns()"><!-- --></A><H3>
deleteOddColumns</H3>
<PRE>
protected void <A HREF="../../src-html\neobio\alignment\Smawk.html#line.297"><B>deleteOddColumns</B></A>()</PRE>
<DL>
<DD>This method simulates a deletion of odd rows by manipulating the <CODE>col</CODE>
 array of indexes. In fact, nothing is deleted, but the indexes are moved to the end
 of the array in a way that they can be easily restored by the
 <CODE>restoreOddColumns</CODE> method using a reverse approach.
<P>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../neobio/alignment/Smawk.html#restoreOddColumns(int)"><CODE>restoreOddColumns(int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="restoreOddColumns(int)"><!-- --></A><H3>
restoreOddColumns</H3>
<PRE>
protected void <A HREF="../../src-html\neobio\alignment\Smawk.html#line.321"><B>restoreOddColumns</B></A>(int&nbsp;original_numcols)</PRE>
<DL>
<DD>Restores the <CODE>col</CODE> array of indexes to the state it was before the
 <CODE>deleteOddColumns</CODE> method was called. It only needs to know how many
 columns there was originally. The indexes that were moved to the end of the array
 are restored to their original position.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>original_numcols</CODE> - the number of columns before the odd ones were deleted<DT><B>See Also:</B><DD><A HREF="../../neobio/alignment/Smawk.html#deleteOddColumns()"><CODE>deleteOddColumns()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="reduce()"><!-- --></A><H3>
reduce</H3>
<PRE>
protected void <A HREF="../../src-html\neobio\alignment\Smawk.html#line.349"><B>reduce</B></A>()</PRE>
<DL>
<DD>This method is the key component of the SMAWK algorithm. It reduces an n x m matrix
 (n rows and m columns), where n >= m, to an n x n matrix by deleting m - n rows
 that are guaranteed to have no maximum value for any column. The result is an
 squared submatrix matrix that contains, for each column c, the row that has the
 maximum value of c in the original matrix. The rows are deleted with the
 <CODE>deleteRow</CODE>method.

 <P>It uses the total monotonicity property of the matrix to identify which rows can
 safely be deleted.
<P>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../neobio/alignment/Smawk.html#deleteRow(int, int)"><CODE>deleteRow(int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="deleteRow(int, int)"><!-- --></A><H3>
deleteRow</H3>
<PRE>
protected void <A HREF="../../src-html\neobio\alignment\Smawk.html#line.391"><B>deleteRow</B></A>(int&nbsp;reduced_rows,
                         int&nbsp;k)</PRE>
<DL>
<DD>This method simulates a deletion of a row in the matrix during the
 <CODE>reduce</CODE> operation. It just moves the index to the end of the array in a
 way that it can be restored afterwards by the <CODE>restoreRows</CODE> method
 (nothing is actually deleted). Deleted indexes are kept in ascending order.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>reduced_rows</CODE> - the current number of rows in the reducing matrix<DD><CODE>k</CODE> - the index of the row to be deleted<DT><B>See Also:</B><DD><A HREF="../../neobio/alignment/Smawk.html#restoreRows(int)"><CODE>restoreRows(int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="restoreRows(int)"><!-- --></A><H3>
restoreRows</H3>
<PRE>
protected void <A HREF="../../src-html\neobio\alignment\Smawk.html#line.414"><B>restoreRows</B></A>(int&nbsp;original_numrows)</PRE>
<DL>
<DD>Restores the <CODE>row</CODE> array of indexes to the state it was before the
 <CODE>reduce</CODE> method was called. It only needs to know how many rows there
 was originally. The indexes that were moved to the end of the array are restored to
 their original position.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>original_numrows</CODE> - the number of rows before the reduction was performed<DT><B>See Also:</B><DD><A HREF="../../neobio/alignment/Smawk.html#deleteRow(int, int)"><CODE>deleteRow(int, int)</CODE></A>, 
<A HREF="../../neobio/alignment/Smawk.html#reduce()"><CODE>reduce()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="naiveComputeColumnMaxima(neobio.alignment.Matrix, int[])"><!-- --></A><H3>
naiveComputeColumnMaxima</H3>
<PRE>
public static void <A HREF="../../src-html\neobio\alignment\Smawk.html#line.459"><B>naiveComputeColumnMaxima</B></A>(<A HREF="../../neobio/alignment/Matrix.html">Matrix</A>&nbsp;matrix,
                                            int[]&nbsp;col_maxima)</PRE>
<DL>
<DD>This is a simpler method for calculating column maxima. It does the same job as
 <CODE>computeColumnMaxima</CODE>, but without complexity of the SMAWK algorithm.

 <P>The matrix is required to be an object that implements the <CODE>Matrix</CODE>
 interface. It is also expected to be monotone. If it is not, the result is
 unpredictable but, unlike <CODE>computeColumnMaxima</CODE>, it cannot lead to an
 ArrayIndexOutOfBoundsException.</P>

 <P>This method does not return the maximum values itself, but just the indexes of
 their rows. Note that the array of column maxima (the computation result) must be
 created beforehand and its size must be equal to the number of columns of the
 matrix.</P>

 <P>It takes advantage of the monotone property of the matrix only (SMAWK explores
 the stronger constraint of total monotonicity), and therefore has a worst case time
 complexity of O(n * m), where n is the number of rows and m is the number of
 columns. However, this method tends to be faster for small matrices because it
 avoids recursions and row and column manipulations.</P>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>matrix</CODE> - the matrix that will have its column maxima computed<DD><CODE>col_maxima</CODE> - the array of column maxima (indexes of the rows containing
 maximum values of each column); this is the computation result<DT><B>See Also:</B><DD><A HREF="../../neobio/alignment/Smawk.html#naiveComputeRowMaxima(neobio.alignment.Matrix, int[])"><CODE>naiveComputeRowMaxima(neobio.alignment.Matrix, int[])</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="naiveComputeRowMaxima(neobio.alignment.Matrix, int[])"><!-- --></A><H3>
naiveComputeRowMaxima</H3>
<PRE>
public static void <A HREF="../../src-html\neobio\alignment\Smawk.html#line.508"><B>naiveComputeRowMaxima</B></A>(<A HREF="../../neobio/alignment/Matrix.html">Matrix</A>&nbsp;matrix,
                                         int[]&nbsp;row_maxima)</PRE>
<DL>
<DD>This is a simpler method for calculating row maxima. It does not use the SMAWK
 algorithm.

 <P>The matrix is required to be an object that implements the <CODE>Matrix</CODE>
 interface. It is also expected to be monotone. If it is not, the result is
 unpredictable but, unlike <CODE>computeColumnMaxima</CODE>, it cannot lead to an
 ArrayIndexOutOfBoundsException.</P>

 <P>This method does not return the maximum values itself, but just the indexes of
 their columns. Note that the array of row maxima (the computation result) must be
 created beforehand and its size must be equal to the number of columns of the
 matrix.</P>

 <P>It takes advantage of the monotone property of the matrix only (SMAWK explores
 the stronger constraint of total monotonicity), and therefore has a worst case time
 complexity of O(n * m), where n is the number of rows and m is the number of
 columns. However, this method tends to be faster for small matrices because it
 avoids recursions and row and column manipulations.</P>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>matrix</CODE> - the matrix that will have its row maxima computed<DD><CODE>row_maxima</CODE> - the array of row maxima (indexes of the columns containing
 maximum values of each row); this is the computation result<DT><B>See Also:</B><DD><A HREF="../../neobio/alignment/Smawk.html#naiveComputeColumnMaxima(neobio.alignment.Matrix, int[])"><CODE>naiveComputeColumnMaxima(neobio.alignment.Matrix, int[])</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="printMatrix()"><!-- --></A><H3>
printMatrix</H3>
<PRE>
protected void <A HREF="../../src-html\neobio\alignment\Smawk.html#line.536"><B>printMatrix</B></A>()</PRE>
<DL>
<DD>Prints the current state of the matrix (reflecting deleted rows and columns) in the
 standard output. It can be used internally for debugging.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="printMatrix(neobio.alignment.Matrix)"><!-- --></A><H3>
printMatrix</H3>
<PRE>
public static void <A HREF="../../src-html\neobio\alignment\Smawk.html#line.559"><B>printMatrix</B></A>(<A HREF="../../neobio/alignment/Matrix.html">Matrix</A>&nbsp;matrix)</PRE>
<DL>
<DD>Prints the contents of an object implementing the matrix interface in the standard
 output. It can be used for debugging.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>matrix</CODE> - a matrix</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_bottom"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<A TARGET="_blank" HREF="http://sourceforge.net"><IMG SRC="http://sourceforge.net/sflogo.php?group_id=87937&amp;type=2" WIDTH="125" HEIGHT="37" BORDER="0" ALT="SourceForge.net" /></A></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../neobio/alignment/ScoringScheme.html"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../neobio/alignment/SmithWaterman.html"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Smawk.html" TARGET="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;
<SCRIPT>
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html" TARGET=""><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
<A HREF="../../allclasses-noframe.html" TARGET=""><B>All Classes</B></A>
</NOSCRIPT>
</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
<FONT SIZE=-1><script language="JavaScript" type="text/javascript" src="http://m1.nedstatbasic.net/basic.js"></script><script language="JavaScript" type="text/javascript" ><!-- 
nedstatbasic("ACZ/LArmjx/k+DNHUelcrNt5+qIQ", 0);
--></script><noscript><a target="_blank" href="http://v1.nedstatbasic.net/stats?ACZ/LArmjx/k+DNHUelcrNt5+qIQ"><img src="http://m1.nedstatbasic.net/n?id=ACZ/LArmjx/k+DNHUelcrNt5+qIQ" border="0" nosave width="18" height="18" alt="Nedstat Basic - Free web site statistics"></a></noscript><A TARGET="_blank" HREF="http://neobio.sourceforge.net">http://neobio.sourceforge.net</A><BR><EM>NeoBio</EM> is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version. <EM>NeoBio</EM> is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with NeoBio; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.</FONT><BR>
</BODY>
</HTML>
